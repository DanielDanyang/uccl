#include <glog/logging.h>
#include <signal.h>

#include <atomic>
#include <thread>

#include "nccl_net.h"
#include "transport.h"
#include "transport_config.h"

using namespace uccl;

const char* PLUGIN_NAME = "RDMA_Plugin";

volatile bool quit = false;

void interrupt_handler(int signal) {
    (void)signal;
    quit = true;
}

enum ReqType {
    ReqTx,
    ReqRx,
    ReqFlush
};

struct ucclRequest {
    enum ReqType type;
    PollCtx *poll_ctx;
    int n;
    int data_len[kMaxRecv];
};

class ucclRequestBuffPool : public BuffPool {
    static constexpr size_t num_elements = kMaxReq << 1; // Send and receive.
    static constexpr size_t element_size = sizeof(ucclRequest);
    public:
     ucclRequestBuffPool() : BuffPool(num_elements, element_size, nullptr) {}
     ~ucclRequestBuffPool() = default;
};

std::optional<RDMAEndpoint> ep;
std::optional<ucclRequestBuffPool> uccl_req_pool;

// Handle generated by pluginListen. And then trasfered to remote side,
// Remove side will call pluginConnect() with this handle.
struct ucclHandle {
    uint32_t ip_addr_u32;
    void *comm;
};
static_assert(sizeof(struct ucclHandle) < NCCL_NET_HANDLE_MAXSIZE, "ucclHandle size too large");

// Hanlde generated by pluginListen for pluginAccept() to use.
struct ucclListenComm {
    int dev;
};

struct ucclBaseComm {
    ConnID conn_id;
};

// Handle generated by pluginAccept.
struct ucclRecvComm {
    struct ucclBaseComm base;
};

// Handle generated by pluginConnect.
struct ucclSendComm {
    struct ucclBaseComm base;
};

struct ConnectAcceptHandler {
    uint32_t ip_addr_u32;
    uint32_t conn_idx;

    bool operator==(const ConnectAcceptHandler& other) const {
        return ip_addr_u32 == other.ip_addr_u32 && conn_idx == other.conn_idx;
    }
};

namespace std {
template <>
struct hash<ConnectAcceptHandler> {
    std::size_t operator()(const ConnectAcceptHandler& key) const {
        return std::hash<uint64_t>{}(*(uint64_t*)&key);
    }
};
}  // namespace std

ncclResult_t pluginInit(ncclDebugLogger_t logFunction)
{
    ep.emplace(GID_INDEX_LIST, NUM_DEVICES, NUM_ENGINES, ENGINE_CPU_START);
    uccl_req_pool.emplace();
    return ncclSuccess;
}

ncclResult_t pluginDevices(int* ndev)
{
    *ndev = NUM_DEVICES;
    return ncclSuccess;
}

ncclResult_t pluginPciPath(int dev, char** path) { return ncclSuccess; }
ncclResult_t pluginPtrSupport(int dev, int* supportedTypes) {
    return ncclSuccess;
}
ncclResult_t pluginGetProperties(int dev, ncclNetProperties_v8_t* props) 
{
    auto factory_dev = RDMAFactory::get_factory_dev(dev);
    sprintf(props->name, "%s%d", IB_DEVICE_NAME_PREFIX, dev);
    props->speed = kLinkBandwidth * 8 / 1e6;
    // Fill for proper topology detection, e.g.
    // /sys/devices/pci0000:00/0000:00:10.0/0000:0b:00.0
    /// TODO:
    props->pciPath = NULL;
    // Only used to detect NICs with multiple PCI attachments.
    props->guid = 0;
    // Add NCCL_PTR_CUDA if GPU Direct RDMA is supported and regMr can take CUDA
    // pointers.
    props->ptrSupport = NCCL_PTR_HOST;
    if (factory_dev->dma_buf_support)
        props->ptrSupport |= NCCL_PTR_CUDA | NCCL_PTR_DMABUF;
    // If you regMr has a fast registration cache, set to 1. If set to 0, user
    // buffer registration may be disabled.
    props->regIsGlobal = 0;
    // Speed in *Mbps*. 100000 means 100G
    props->speed = 400000;
    // Port number, used in conjunction with guid
    props->port = 0;
    // Custom latency (used to help tuning if latency is high. If set to 0, use
    // default NCCL values.
    props->latency = 0;
    // Maximum number of comm objects we can create.
    props->maxComms = 1024 * 1024;
    // Maximum number of receive operations taken by irecv().
    props->maxRecvs = 1;
    // Coupling with NCCL network device-side code.
    props->netDeviceType = (ncclNetDeviceType)0;
    props->netDeviceVersion = NCCL_NET_DEVICE_INVALID_VERSION;
    return ncclSuccess;
}

// To create a connection, NCCL will start by calling listen on the receiver
// side. This function takes a device number as input argument, and should
// return a local listenComm object, and a handle to pass to the other side, so
// that the sender side can connect to the receiver. The handle is a buffer of
// size NCCL_NET_HANDLE_MAXSIZE and is provided by NCCL. This call should never
// block, but contrary to connect and accept, listenComm should never be NULL if
// the call succeeds.
ncclResult_t pluginListen(int dev, void* opaqueHandle, void** listenComm)
{
    struct ucclHandle *handle = (struct ucclHandle *)opaqueHandle;
    memset(handle, 0, sizeof(struct ucclHandle));
    
    // Get the IP address from RDMAFactory.
    auto factory_dev = RDMAFactory::get_factory_dev(dev);
    handle->ip_addr_u32 = str_to_ip(factory_dev->local_ip_str);
    handle->comm = nullptr;
    
    struct ucclListenComm *comm = 
        (struct ucclListenComm *)calloc(1, sizeof(struct ucclListenComm));
    
    comm->dev = dev;
    *listenComm = comm;

    return ncclSuccess;
}

// NCCL will use its bootstrap infrastructure to provide the handle to the
// sender side, then call connect on the sender side on a given device index
// dev, providing the handle. connect should not block either, and instead set
// sendComm to NULL and return ncclSuccess. In that case, NCCL will call accept
// again until it succeeds.
ncclResult_t pluginConnect(int dev, void* opaque_handle, void** sendComm,
                           ncclNetDeviceHandle_v8_t** /*sendDevComm*/)
{
    struct ucclHandle *handle = (struct ucclHandle *)opaque_handle;
    
    struct ucclSendComm *scomm = 
        (struct ucclSendComm *)calloc(1, sizeof(struct ucclSendComm));
    
    std::string remote_ip_str = ip_to_str(handle->ip_addr_u32);
    scomm->base.conn_id = ep->uccl_connect(dev, remote_ip_str);

    *sendComm = scomm;

    return ncclSuccess;
}

// To finalize the connection, the receiver side will call accept on the
// listenComm returned by the listen call previously. If the sender did not
// connect yet, accept should not block. It should return ncclSuccess, setting
// recvComm to NULL. NCCL will call accept again until it succeeds.
ncclResult_t pluginAccept(void* listenComm, void** recvComm,
                          ncclNetDeviceHandle_v8_t** /*recvDevComm*/) {
    
    struct ucclListenComm *lcomm = (struct ucclListenComm *)listenComm;

    struct ucclRecvComm *rcomm = 
        (struct ucclRecvComm *)calloc(1, sizeof(struct ucclRecvComm));
    
    std::string remote_ip_str;
    rcomm->base.conn_id = ep->uccl_accept(lcomm->dev, remote_ip_str);

    *recvComm = rcomm;

    return ncclSuccess;
}

ncclResult_t pluginRegMr(void* collComm, void* data, size_t size, int type,
                         void** mhandle) {
    int ret;
    struct ucclBaseComm *base = (struct ucclBaseComm *)collComm;
    ret = ep->uccl_regmr(base->conn_id, data, size, type, (struct Mhandle **)mhandle);
    return ret == 0 ? ncclSuccess : ncclInternalError;
}

ncclResult_t pluginRegMrDmaBuf(void* collComm, void* data, size_t size,
                               int type, uint64_t offset, int fd,
                               void** mhandle) {
    int ret;
    struct ucclBaseComm *base = (struct ucclBaseComm *)collComm;
    ret = ep->uccl_regmr_dmabuf(base->conn_id, data, size, type, offset, fd, (struct Mhandle **)mhandle);
    return ret == 0 ? ncclSuccess : ncclInternalError;
}

ncclResult_t pluginDeregMr(void* collComm, void* mhandle) {
    struct ucclBaseComm *base = (struct ucclBaseComm *)collComm;
    ep->uccl_deregmr(base->conn_id, (struct Mhandle *)mhandle);
    return ncclSuccess;
}

ncclResult_t pluginIsend(void* sendComm, void* data, int size, int tag,
                         void* mhandle, void** request) 
{
    struct ucclSendComm *scomm = (struct ucclSendComm *)sendComm;
    auto conn_id = scomm->base.conn_id;
    struct Mhandle *mh = (struct Mhandle *)mhandle;

    uint64_t addr;
    if (uccl_req_pool->alloc_buff(&addr)) return ncclInternalError;
    struct ucclRequest *req = reinterpret_cast<struct ucclRequest *>(addr);

    req->poll_ctx = ep->uccl_send_async(conn_id, mh, data, size);

    req->type = ReqTx;
    req->data_len[0] = size;

    *request = req;

    return ncclSuccess;
}

ncclResult_t pluginIrecv(void* recvComm, int n, void** data, int* sizes,
                         int* tags, void** mhandles, void** request) 
{
    struct ucclRecvComm *rcomm = (struct ucclRecvComm *)recvComm;
    auto conn_id = rcomm->base.conn_id;
    struct Mhandle **mhs = (struct Mhandle **)mhandles;

    uint64_t addr;
    if (uccl_req_pool->alloc_buff(&addr)) return ncclInternalError;
    struct ucclRequest *req = reinterpret_cast<struct ucclRequest *>(addr);

    req->poll_ctx = ep->uccl_recv_async(conn_id, mhs, data, sizes, n);

    req->type = ReqRx;
    for (int i = 0; i < n; i++) req->data_len[i] = sizes[i];
    req->n = n;

    *request = req;

    return ncclSuccess;
}

ncclResult_t pluginIflush(void* recvComm, int n, void** data, int* sizes,
                          void** mhandles, void** request) {
    struct ucclRecvComm *rcomm = (struct ucclRecvComm *)recvComm;
    auto conn_id = rcomm->base.conn_id;
    struct Mhandle **mhs = (struct Mhandle **)mhandles;

    uint64_t addr;
    if (uccl_req_pool->alloc_buff(&addr)) return ncclInternalError;
    struct ucclRequest *req = reinterpret_cast<struct ucclRequest *>(addr);

    req->poll_ctx = ep->uccl_flush(conn_id, mhs, data, sizes, n);

    req->type = ReqFlush;

    *request = req;
    
    return ncclSuccess;
}

ncclResult_t pluginTest(void* request, int* done, int* size) {

    struct ucclRequest *req = 
        reinterpret_cast<struct ucclRequest *>(request);
    
    if (ep->uccl_poll_once(req->poll_ctx)) {
        *done = 1;
        if (req->type == ReqTx) {
            size[0] = req->data_len[0];
        } else if (req->type == ReqRx) {
            for (int i = 0; i < req->n; i++) size[i] = req->data_len[i];
        } else if (req->type == ReqFlush) {
            // Do nothing.
        }
        uccl_req_pool->free_buff(reinterpret_cast<uint64_t>(req));
    } else {
        *done = 0;
    }

    return ncclSuccess;
}

ncclResult_t pluginCloseSend(void* sendComm) 
{
    struct ucclSendComm *scomm = (struct ucclSendComm *)sendComm;
    free(scomm);
    return ncclSuccess; 
}
ncclResult_t pluginCloseRecv(void* recvComm) 
{
    struct ucclRecvComm *rcomm = (struct ucclRecvComm *)recvComm;
    free(rcomm);
    return ncclSuccess; 
}
ncclResult_t pluginCloseListen(void* listenComm) 
{
    struct ucclListenComm *comm = (struct ucclListenComm *)listenComm;
    free(comm);
    return ncclSuccess; 
}

volatile ncclNet_v8_t ncclNetPlugin_v8 = {
    .name = PLUGIN_NAME,
    .init = pluginInit,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties,
    .listen = pluginListen,
    .connect = pluginConnect,
    .accept = pluginAccept,
    .regMr = pluginRegMr,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend,
    .irecv = pluginIrecv,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = nullptr,
    .irecvConsumed = nullptr,
};
