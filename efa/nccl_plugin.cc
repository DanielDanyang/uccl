#include <glog/logging.h>

#include <atomic>
#include <mutex>
#include <thread>

#include "nccl_net.h"
#include "transport.h"
#include "transport_config.h"

using namespace uccl;

const char *PLUGIN_NAME = "EFA_Plugin";

enum ReqType {
    ReqTx,
    ReqRx,
    ReqFlush,
};

struct UcclRequest {
    ReqType type;
    int n;
    int send_len = 0;
    int recv_len[kMaxMultiRecv] = {0};
    PollCtx *poll_ctx = nullptr;
    void *req_pool = nullptr;

    void clear() { memset(this, 0, sizeof(UcclRequest)); }
};

class UcclRequestBuffPool : public BuffPool {
    static constexpr size_t num_elements = 4096;  // Send and receive.
    static constexpr size_t element_size = sizeof(UcclRequest);

   public:
    UcclRequestBuffPool() : BuffPool(num_elements, element_size, nullptr) {}
    ~UcclRequestBuffPool() = default;
};

std::shared_ptr<Endpoint> ep;

enum ConnState { kConnInit = 0, kConnConnecting, kConnConnected };

struct UcclBaseComm {
    int vdev;
    ConnID conn_id;
    std::shared_ptr<UcclRequestBuffPool> uccl_req_pool;
};

struct AsyncAcceptState {
    struct UcclBaseComm base;
    std::string remote_ip_str;
    int remote_vdev;
};

struct AsyncConnectState {
    struct UcclBaseComm base;
};

// Handle generated by pluginListen. And then trasfered to remote side,
// Remote side will call pluginConnect() with this handle.
struct UcclHandle {
    uint32_t ip_addr_u32;
    int remote_vdev;
    std::atomic<enum ConnState> state = kConnInit;
    AsyncConnectState connect_buffer;
    std::atomic<bool> fence = false;
};
static_assert(sizeof(struct UcclHandle) < NCCL_NET_HANDLE_MAXSIZE,
              "UcclHandle size too large");

// Hanlde generated by pluginListen for pluginAccept() to use.
struct UcclListenComm {
    int vdev;
    int remote_dev;
    std::atomic<enum ConnState> state = kConnInit;
    AsyncAcceptState accept_buffer;
    std::atomic<bool> fence = false;
};

static void write_barrier(std::atomic<bool> &fence) {
    std::atomic_thread_fence(std::memory_order_release);
    std::atomic_store_explicit(&fence, true, std::memory_order_relaxed);
}
static void read_barrier(std::atomic<bool> &fence) {
    std::ignore = std::atomic_load_explicit(&fence, std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
}

// Handle generated by pluginAccept.
struct UcclRecvComm {
    struct UcclBaseComm base;
    std::string remote_ip_str;
    int remote_vdev;
};

// Handle generated by pluginConnect.
struct UcclSendComm {
    struct UcclBaseComm base;
};

ncclResult_t pluginInit(ncclDebugLogger_t logFunction) {
    // FLAGS_v = 4;
    ep = std::make_shared<Endpoint>();
    return ncclSuccess;
}

ncclResult_t pluginDevices(int *ndev) {
    // To ease NIC-GPU mapping on p4d, we virtualize each NIC into two.
    *ndev = get_vdev(NUM_DEVICES);
    return ncclSuccess;
}

/// @ref ncclIbGetPciPath
ncclResult_t pluginPciPath(const char *ib_name, char **path) {
    char devicePath[256];
    snprintf(devicePath, 256, "/sys/class/infiniband/%s/device", ib_name);
    char *p = realpath(devicePath, NULL);
    if (p == NULL) {
        LOG(ERROR) << "Could not find device path for " << ib_name;
        return ncclInternalError;
    }
    *path = p;
    return ncclSuccess;
}

ncclResult_t pluginGetProperties(int vdev, ncclNetProperties_v8_t *props) {
    auto pdev = get_pdev(vdev);
    auto factory_dev = EFAFactory::GetEFADevice(pdev);
    const char *v_suffix = vdev % 2 == 0 ? "_0" : "_1";
    int v_int = vdev % 2 == 0 ? 0 : 1;

    char *vib_name = new char[40];
    strcpy(vib_name, factory_dev->ib_name);
    strcat(vib_name, v_suffix);

    props->name = vib_name;

    // Speed in *Mbps*. 100000 means 100G
    props->speed = kLinkBandwidth * 8 / 1e6;

    pluginPciPath(factory_dev->ib_name, &props->pciPath);
    strcat(props->pciPath, v_suffix);

    // Only used to detect NICs with multiple PCI attachments.
    props->guid = factory_dev->dev_attr.sys_image_guid + v_int;
    LOG(INFO) << "dev " << vdev << " guid " << props->guid;

    props->ptrSupport = NCCL_PTR_HOST;
    if (factory_dev->dma_buf_support)
        props->ptrSupport |= NCCL_PTR_CUDA | NCCL_PTR_DMABUF;

    // If you regMr has a fast registration cache, set to 1. If set to 0, user
    // buffer registration may be disabled.
    props->regIsGlobal = 0;

    // Port number, used in conjunction with guid
    props->port = EFA_PORT_NUM;
    // Custom latency (used to help tuning if latency is high. If set to 0, use
    // default NCCL values.
    props->latency = 0;
    // Maximum number of comm objects we can create.
    props->maxComms = 1024 * 1024;
    // Maximum number of receive operations taken by irecv().
    props->maxRecvs = kMaxMultiRecv;
    // Coupling with NCCL network device-side code.
    props->netDeviceType = NCCL_NET_DEVICE_HOST;
    props->netDeviceVersion = NCCL_NET_DEVICE_INVALID_VERSION;
    return ncclSuccess;
}

// To create a connection, NCCL will start by calling listen on the receiver
// side. This function takes a device number as input argument, and should
// return a local listenComm object, and a handle to pass to the other side, so
// that the sender side can connect to the receiver. The handle is a buffer of
// size NCCL_NET_HANDLE_MAXSIZE and is provided by NCCL. This call should never
// block, but contrary to connect and accept, listenComm should never be NULL if
// the call succeeds.
ncclResult_t pluginListen(int vdev, void *opaque_handle, void **listenComm) {
    auto pdev = get_pdev(vdev);
    struct UcclHandle *handle = (struct UcclHandle *)opaque_handle;
    memset(handle, 0, sizeof(struct UcclHandle));

    // Fill out handle which will be passed to the other side.
    auto factory_dev = EFAFactory::GetEFADevice(pdev);
    handle->ip_addr_u32 = str_to_ip(factory_dev->local_ip_str);
    handle->remote_vdev = vdev;

    struct UcclListenComm *lcomm =
        (struct UcclListenComm *)calloc(1, sizeof(struct UcclListenComm));

    lcomm->vdev = vdev;
    lcomm->state = kConnInit;
    *listenComm = lcomm;

    LOG(INFO) << "pluginListen on vdev: " << vdev;

    return ncclSuccess;
}

// NCCL will use its bootstrap infrastructure to provide the handle to the
// sender side, then call connect on the sender side on a given device index
// dev, providing the handle. connect should not block either, and instead set
// sendComm to NULL and return ncclSuccess. In that case, NCCL will call accept
// again until it succeeds.
ncclResult_t pluginConnect(int vdev, void *opaque_handle, void **sendComm,
                           ncclNetDeviceHandle_v8_t ** /*sendDevComm*/) {
    auto pdev = get_pdev(vdev);
    struct UcclHandle *handle = (struct UcclHandle *)opaque_handle;

    std::string remote_ip_str = ip_to_str(handle->ip_addr_u32);

    struct UcclSendComm *scomm =
        (struct UcclSendComm *)calloc(1, sizeof(struct UcclSendComm));

    if (handle->state == kConnInit) {
        LOG(INFO) << "pluginConnect on vdev: " << vdev << " remote_ip_str "
                  << remote_ip_str;
        handle->state = kConnConnecting;
        // Delegate connection to another thread.
        std::thread t = std::thread([vdev, handle, remote_ip_str] {
            LOG(INFO) << "before uccl_connect";
            handle->connect_buffer.base.conn_id =
                ep->uccl_connect(vdev, handle->remote_vdev, remote_ip_str);
            LOG(INFO) << "after uccl_connect";
            handle->connect_buffer.base.vdev = vdev;
            handle->state = kConnConnected;
            write_barrier(handle->fence);
        });
        t.detach();
        *sendComm = nullptr;
        free(scomm);
    } else if (handle->state == kConnConnecting) {
        *sendComm = nullptr;
        free(scomm);
    } else {
        read_barrier(handle->fence);
        DCHECK(handle->state == kConnConnected);
        scomm->base = handle->connect_buffer.base;
        scomm->base.uccl_req_pool = std::make_shared<UcclRequestBuffPool>();
        *sendComm = scomm;
    }

    if (*sendComm) {
        printf("Connected to %s/%d on vdev: %d, %lu\n", remote_ip_str.c_str(),
               handle->remote_vdev, vdev, scomm->base.conn_id.flow_id);
    }

    return ncclSuccess;
}

// To finalize the connection, the receiver side will call accept on the
// listenComm returned by the listen call previously. If the sender did not
// connect yet, accept should not block. It should return ncclSuccess, setting
// recvComm to NULL. NCCL will call accept again until it succeeds.
ncclResult_t pluginAccept(void *listenComm, void **recvComm,
                          ncclNetDeviceHandle_v8_t ** /*recvDevComm*/) {
    struct UcclListenComm *lcomm = (struct UcclListenComm *)listenComm;

    struct UcclRecvComm *rcomm =
        (struct UcclRecvComm *)calloc(1, sizeof(struct UcclRecvComm));

    if (lcomm->state == kConnInit) {
        LOG(INFO) << "pluginAccept on vdev: " << lcomm->vdev;
        lcomm->state = kConnConnecting;
        // Delegate connection to another thread.
        std::thread t = std::thread([lcomm] {
            std::string remote_ip_str;
            int remote_vdev;
            LOG(INFO) << "before uccl_accept";
            lcomm->accept_buffer.base.conn_id =
                ep->uccl_accept(lcomm->vdev, &remote_vdev, remote_ip_str);
            LOG(INFO) << "after uccl_accept";
            lcomm->accept_buffer.base.vdev = lcomm->vdev;
            lcomm->accept_buffer.remote_ip_str = remote_ip_str;
            lcomm->accept_buffer.remote_vdev = remote_vdev;
            lcomm->state = kConnConnected;
            write_barrier(lcomm->fence);
        });
        t.detach();
        *recvComm = nullptr;
        free(rcomm);
    } else if (lcomm->state == kConnConnecting) {
        *recvComm = nullptr;
        free(rcomm);
    } else {
        read_barrier(lcomm->fence);
        DCHECK(lcomm->state == kConnConnected);
        rcomm->base = lcomm->accept_buffer.base;
        rcomm->base.uccl_req_pool = std::make_shared<UcclRequestBuffPool>();
        rcomm->remote_ip_str = lcomm->accept_buffer.remote_ip_str;
        rcomm->remote_vdev = lcomm->accept_buffer.remote_vdev;
        *recvComm = rcomm;
    }

    if (*recvComm) {
        printf("Accepted from %s/%d on vdev: %d, %lu\n",
               rcomm->remote_ip_str.c_str(), rcomm->remote_vdev, lcomm->vdev,
               rcomm->base.conn_id.flow_id);
    }

    return ncclSuccess;
}

static std::atomic<uint32_t> reg_cnt = 0;

ncclResult_t pluginRegMr(void *collComm, void *data, size_t size, int type,
                         void **mhandle) {
    int ret;
    struct UcclBaseComm *base = (struct UcclBaseComm *)collComm;
    auto dev_idx = get_dev_idx_by_engine_idx(base->conn_id.engine_idx);
    auto vdev_idx = get_vdev(dev_idx);
    checkMemoryLocation(data);

    LOG(INFO) << "pluginRegMr, " << size << ", " << base->conn_id.flow_id
              << " vdev_idx " << vdev_idx;
    ret = ep->uccl_regmr(dev_idx, data, size, type, (struct Mhandle **)mhandle);
    reg_cnt++;

    return ret == 0 ? ncclSuccess : ncclInternalError;
}

ncclResult_t pluginRegMrDmaBuf(void *collComm, void *data, size_t size,
                               int type, uint64_t offset, int fd,
                               void **mhandle) {
    int ret;
    struct UcclBaseComm *base = (struct UcclBaseComm *)collComm;
    auto dev_idx = get_dev_idx_by_engine_idx(base->conn_id.engine_idx);
    auto vdev_idx = get_vdev(dev_idx);
    checkMemoryLocation(data);

    LOG(INFO) << "pluginRegMrDmaBuf, " << size << ", " << base->conn_id.flow_id
              << " vdev_idx " << vdev_idx;
    ret = ep->uccl_regmr_dmabuf(dev_idx, data, size, type, offset, fd,
                                (struct Mhandle **)mhandle);
    reg_cnt++;

    return ret == 0 ? ncclSuccess : ncclInternalError;
}

ncclResult_t pluginDeregMr(void *collComm, void *mhandle) {
    struct UcclBaseComm *base = (struct UcclBaseComm *)collComm;
    ep->uccl_deregmr((struct Mhandle *)mhandle);
    LOG(INFO) << "pluginDeregMr, " << base->conn_id.flow_id;
    if (--reg_cnt == 0) ep.reset();
    return ncclSuccess;
}

ncclResult_t pluginIsend(void *sendComm, void *data, int size, int tag,
                         void *mhandle, void **request) {
    struct UcclSendComm *scomm = (struct UcclSendComm *)sendComm;
    auto conn_id = scomm->base.conn_id;
    struct Mhandle *mh = (struct Mhandle *)mhandle;
    // checkMemoryLocation(data);

    uint64_t addr;
    auto vdev = scomm->base.vdev;
    {
        if (scomm->base.uccl_req_pool->alloc_buff(&addr)) {
            *request = nullptr;
            return ncclSuccess;
        }
    }

    struct UcclRequest *req = reinterpret_cast<struct UcclRequest *>(addr);
    req->type = ReqTx;
    req->n = 1;
    req->send_len = size;
    req->poll_ctx = ep->uccl_send_async(conn_id, data, req->send_len, mh);
    req->req_pool = (void *)scomm->base.uccl_req_pool.get();

    *request = req;

    VLOG(3) << "pluginIsend on vdev: " << vdev << ", size: " << size
            << ", flow " << conn_id.flow_id;

    return ncclSuccess;
}

ncclResult_t pluginIrecv(void *recvComm, int n, void **data, int *sizes,
                         int *tags, void **mhandles, void **request) {
    struct UcclRecvComm *rcomm = (struct UcclRecvComm *)recvComm;
    auto conn_id = rcomm->base.conn_id;
    struct Mhandle **mhs = (struct Mhandle **)mhandles;
    // checkMemoryLocation(data[0]);

    uint64_t addr;
    auto vdev = rcomm->base.vdev;
    {
        if (rcomm->base.uccl_req_pool->alloc_buff(&addr)) {
            *request = nullptr;
            return ncclSuccess;
        }
    }

    struct UcclRequest *req = reinterpret_cast<struct UcclRequest *>(addr);
    req->type = ReqRx;
    req->n = n;
    req->poll_ctx =
        ep->uccl_recv_multi_async(conn_id, data, req->recv_len, mhs, n);
    req->req_pool = (void *)rcomm->base.uccl_req_pool.get();

    *request = req;

    VLOG(3) << "pluginIrecv on vdev: " << vdev << ", size: " << sizes[0]
            << ", flow " << conn_id.flow_id;

    return ncclSuccess;
}

ncclResult_t pluginIflush(void *recvComm, int n, void **data, int *sizes,
                          void **mhandles, void **request) {
    return ncclSuccess;
}

ncclResult_t pluginTest(void *request, int *done, int *size) {
    struct UcclRequest *req = reinterpret_cast<struct UcclRequest *>(request);

    if (ep->uccl_poll_once(req->poll_ctx)) {
        *done = 1;
        if (req->type == ReqTx) {
            size[0] = req->send_len;
            VLOG(3) << "pluginTest ReqTx done";
        } else if (req->type == ReqRx) {
            for (int i = 0; i < req->n; i++) size[i] = req->recv_len[i];
            VLOG(3) << "pluginTest ReqRx done";
        } else if (req->type == ReqFlush) {
            // Do nothing.
        }
        {
            auto uccl_req_pool =
                reinterpret_cast<UcclRequestBuffPool *>(req->req_pool);
            uccl_req_pool->free_buff(reinterpret_cast<uint64_t>(req));
        }
    } else {
        *done = 0;
    }

    return ncclSuccess;
}

ncclResult_t pluginCloseSend(void *sendComm) {
    struct UcclSendComm *scomm = (struct UcclSendComm *)sendComm;
    free(scomm);
    return ncclSuccess;
}
ncclResult_t pluginCloseRecv(void *recvComm) {
    struct UcclRecvComm *rcomm = (struct UcclRecvComm *)recvComm;
    free(rcomm);
    return ncclSuccess;
}
ncclResult_t pluginCloseListen(void *listenComm) {
    struct UcclListenComm *comm = (struct UcclListenComm *)listenComm;
    free(comm);
    return ncclSuccess;
}

volatile ncclNet_v8_t ncclNetPlugin_v8 = {
    .name = PLUGIN_NAME,
    .init = pluginInit,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties,
    .listen = pluginListen,
    .connect = pluginConnect,
    .accept = pluginAccept,
    .regMr = pluginRegMr,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend,
    .irecv = pluginIrecv,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = nullptr,
    .irecvConsumed = nullptr,
};
